namespace Reloaded.Mod.Launcher.Lib.Models.Model.Application;

/// <summary>
/// Specialized version of <see cref="BooleanGenericTuple{TGeneric}"/> intended for storing bindable mod information.
/// </summary>
public class ModEntry : ObservableObject, IEquatable<ModEntry>
{
    private static Type[] _sharedTypes = { typeof(IConfiguratorV1) };

    // ReSharper disable once UnusedMember.Global

    /// <summary/>
    public const string NameOfEnabled = nameof(Enabled);

    /// <summary>
    /// Whether the current mod is enabled.
    /// </summary>
    public bool? Enabled            { get; set; }

    /// <summary>
    /// Whether the state of the checkbox can be edited or not.
    /// </summary>
    public bool IsEditable          { get; set; }
    
    /// <summary>
    /// The mod to toggle the state for.
    /// </summary>
    public PathTuple<ModConfig> Tuple  { get; set; }

    /// <summary>
    /// Whether the mod configurable through Reloaded.
    /// </summary>
    public bool IsConfigurable { get; set; }

    /// <summary>
    /// Whether the mod supports updating.
    /// </summary>
    public bool IsUpdatable { get; set; }

    /// <summary>
    /// Whether the mod has an update available.
    /// </summary>
    public bool HasNewUpdate { get; set; }

    /// <summary>
    /// Whether the mod has an update available.
    /// </summary>
    public bool IsSupportable { get; set; }

    /// <inheritdoc />
    public ModEntry(bool? enabled, PathTuple<ModConfig> tuple)
    {
        IsEditable = !tuple.Config.IsLibrary;
        Enabled = !IsEditable ? null : enabled;
        Tuple = tuple;
        //IsConfigurable = HasConfigurator();
        //IsUpdatable = PackageResolverFactory.HasAnyConfiguredResolver(Tuple);
        //HasNewUpdate = IsUpdatable && Random.Shared.Next(4) == 0;
        //IsSupportable = Random.Shared.Next(3) == 0;
    }

    // Disallowed inlining to ensure nothing from library can be kept alive by stack references etc.
    [MethodImpl(MethodImplOptions.NoInlining)]
    private bool HasConfigurator()
    {
        // TODO: Opening the publish window causes mods to refresh constantly
        // freezing the app here.
        var config = Tuple.Config;
        string dllPath = config.GetManagedDllPath(Tuple.Path);

        if (!File.Exists(dllPath))
            return false;

        using var loader = PluginLoader.CreateFromAssemblyFile(dllPath, true, _sharedTypes, config =>
        {
            config.DefaultContext = AssemblyLoadContext.GetLoadContext(Assembly.GetExecutingAssembly())!;
            config.IsLazyLoaded = true;
            config.LoadInMemory = true;
        });

        var assembly = loader.LoadDefaultAssembly();
        var types = assembly.GetTypes();
        var entryPoint = types.FirstOrDefault(t => typeof(IConfiguratorV1).IsAssignableFrom(t) && !t.IsAbstract);

        return entryPoint != null;
    }

    // Autogenerated by R# 

    #region Autogenerated
    /// <inheritdoc/>
    public bool Equals(ModEntry? other)
    {
        if (ReferenceEquals(null, other)) return false;
        if (ReferenceEquals(this, other)) return true;
        return Enabled == other.Enabled && IsEditable == other.IsEditable && Tuple.Equals(other.Tuple);
    }

    /// <inheritdoc/>
    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj)) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;
        return Equals((ModEntry)obj);
    }

    /// <inheritdoc/>
    public override int GetHashCode()
    {
        return Tuple.GetHashCode();
    }
    #endregion
}